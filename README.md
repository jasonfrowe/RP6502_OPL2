# RP6502-OPL2 Jukebox
### FPGA-Accelerated FM Synthesis for the Picocomputer

## Note about branches:
- The `main` branch contains the latest stable code for RP6502 Picocomputer with OPL2 support.  This version uses midi2pix.py for MIDI to binary conversion, and uses interupt-driven playback at 120Hz/140Hz.
- The `VGM` branch is for playback of VGM files generated by Furnace.  vgm2pix.py is used for conversion, which produces a raw command stream that is sent to the OPL2.  
- The 'streaming' branch is work done to read in VGM data from the USB storage device at runtime, rather than baking it into ROM.  This is experimental and not stable at the moment (I have a logic error to sort out.)

This project implements a cycle-accurate Yamaha YM3812 (OPL2) sound system for the RP6502 Picocomputer. It utilizes a TinyFPGA BX as a high-speed PIX bus sniffer and hardware command buffer, allowing the 65C02 to stream complex FM music with zero CPU-side wait states.

## ðŸš€ Key Features
- **FPGA-Side FIFO:** A 512-entry hardware buffer handles the OPL2's strict timing requirements (3.3Âµs and 23Âµs recovery times).
- **Dynamic Voice Management:** The Python toolchain handles polyphony and Least-Recently Used (LRU) voice allocation.
- **High-Resolution Timing:** Supports 120Hz/140Hz playback via a fractional VSync accumulator.
- **Pre-Baked Frequency Math:** Offloads F-Number and Block calculations to Python for a lightweight 6502 sequencer.

---

## ðŸ“š API Reference (`opl.c`)

The following functions provide control over the OPL2 hardware and the music sequencer.

### System Control
| Function | Description |
| :--- | :--- |
| `void opl_init()` | **Scorched Earth Reset.** Silences all channels, wipes all 256 OPL registers, resets drum flags, and enables OPL2 Waveform Select. Call this at program start. |
| `void opl_fifo_clear()` | **Hardware Reset.** Directly triggers the FPGA to flush its command FIFO via XRAM `$FF02`. Use this to recover from buffer overflows. |
| `void opl_clear()` | Soft-clears all registers to `0x00`. |
| `void opl_write(uint8_t reg, uint8_t data)` | Low-level write. Sends a Register/Value pair to XRAM `$FF00/$FF01`. The FPGA FIFO automatically handles the required OPL2 timing delays. |

### Note & Voice Control
| Function | Description |
| :--- | :--- |
| `void OPL_NoteOn(uint8_t chan, uint8_t note)` | Triggers a note on a specific channel (0-8). If the channel is marked as a drum, it forces the pitch to Middle C (60) to ensure FM percussion sounds correct. |
| `void OPL_NoteOff(uint8_t chan)` | Releases the note on the specified channel. Uses shadow registers to preserve the current frequency/octave while clearing the Key-On bit. |
| `void OPL_SetVolume(uint8_t chan, uint8_t vol)` | Maps MIDI velocity (0-127) to OPL2 Total Level (63-0). Note: OPL2 volume is inverted (0 is loudest). |
| `void opl_silence_all()` | Immediately sends a Key-Off command to all 9 OPL channels. |

### Sequencer Engine
| Function | Description |
| :--- | :--- |
| `void update_song()` | The core playback loop. Reads the 6-byte binary records from XRAM, processes Note/Patch events, and manages `wait_ticks`. |
| `uint16_t midi_to_opl_freq(uint8_t note)` | Helper to convert MIDI note numbers to OPL2 Block/F-Number format based on a 4.0MHz master clock. |

---

## ðŸ›  Hardware Architecture

### The PIX Interface
The TinyFPGA BX sniffs the RP6502 PIX bus using DDR sampling.
- **Address Mapping:** 
    - `$FF00`: OPL2 Register Index
    - `$FF01`: OPL2 Register Data
    - `$FF02`: FIFO Flush (Write `1` to trigger)

### Audio Chain
1. **JTOPL2 Core:** Cycle-accurate OPL2 implementation.
2. **Sigma-Delta DAC:** 16-bit PDM DAC running at 16MHz.
3. **External Filter:** RC low-pass filter (1kÎ© / 0.1ÂµF) on Pin 14 (H9).

## ðŸ”Œ Pin Mapping (TinyFPGA BX)
| Function | FPGA Pin | RP6502 Pin |
| :--- | :--- | :--- |
| PHI2 (Bus Clock) | A2 | Pin 1 |
| PIX[0:3] | A1, B1, C2, C1 | Pins 2, 3, 4, 5 |
| AUDIO_OUT | H9 | Pin 14 |
| LED | B3 | Onboard |

## ðŸ“‚ Software Pipeline

### 1. Conversion (`midi2pix.py`)
The Python script converts MIDI files into an optimized 6-byte binary format:
`[Type][Channel][Data1][Data2][Delay_After (16-bit)]`

**Features:**
- **Lazy Patching:** Only sends instrument operator writes during channel context switches.
- **Voice Manager:** Handles polyphony using a Least-Recently Used (LRU) algorithm.
- **Pre-calculated Frequencies:** Eliminates 6502-side math to prevent lag.

```bash
python3 tools/midi2pix.py music/sq3_theme.mid src/music.bin
```

### 2. The 6502 Engine
The engine utilizes the `timer_accumulator` logic in `main.c` to drive `update_song()` at the desired frequency (e.g., 120Hz) while keeping the game logic locked to the 60Hz VSync.

## ðŸ›  Build & Run
1. **Flash FPGA:** `tinyprog -p top.bin`
2. **Compile 6502:** Use the RP6502 SDK (LLVM-MOS).
3. **Upload:**
   ```bash
   rp6502.py RP6502_OPL2.rp6502 -a 0x10000:src/music.bin
   ```

## ðŸ“œ Credits
- **JTOPL2 Core:** Jose Tejada (Jotego).
- **RP6502 Hardware:** Lawrence Manning.
- **Sequencer Logic:** Jason Rowe.